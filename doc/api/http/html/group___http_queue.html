<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>http: HttpQueue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">http&#160;<span id="projectnumber">1.0</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>HttpQueue</h1>  </div>
</div>
<div class="contents">

<p>Queue object.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga9148e04c9f1e0be26f5c05fa069671db">httpDisableQueue</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a queue.  <a href="#ga9148e04c9f1e0be26f5c05fa069671db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gab1edc4220fc6d43c9f3890a791203d2c">httpDiscardData</a> (HttpQueue *q, <a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> removePackets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard all data from the queue.  <a href="#gab1edc4220fc6d43c9f3890a791203d2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga346146f107faba9923caa9e003c4d3a1">httpEnableQueue</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a queue.  <a href="#ga346146f107faba9923caa9e003c4d3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HttpPacket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga289893521c40788edc06280530167a85">httpGetPacket</a> (struct HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next packet from a queue.  <a href="#ga289893521c40788edc06280530167a85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga141d826d025030d4d8c6b3e29cc82b54">httpGetQueueRoom</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the room in the queue.  <a href="#ga141d826d025030d4d8c6b3e29cc82b54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga0312ce08a79bdfb49854b0693480b661">httpIsEof</a> (struct HttpConn *conn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test is the connection has received all incoming content.  <a href="#ga0312ce08a79bdfb49854b0693480b661"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gafb4d0f9b9d5caa21b605e015154de36e">httpIsPacketTooBig</a> (struct HttpQueue *q, HttpPacket *packet)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a packet is too big.  <a href="#gafb4d0f9b9d5caa21b605e015154de36e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gacd6cd97710d608b988e9169637dec43c">httpIsQueueEmpty</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the queue is empty.  <a href="#gacd6cd97710d608b988e9169637dec43c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga7ca69588fa498e117f23b73956ae66f0">httpJoinPacketForService</a> (struct HttpQueue *q, HttpPacket *packet, <a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> serviceQ)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a packet onto the service queue.  <a href="#ga7ca69588fa498e117f23b73956ae66f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga476c8e99e1c02292781748edd59190dc">httpJoinPackets</a> (HttpQueue *q, <a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the packets together.  <a href="#ga476c8e99e1c02292781748edd59190dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga8bdb0b39ec10ee344c8e65179800836b">httpPutBackPacket</a> (struct HttpQueue *q, HttpPacket *packet)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a packet back onto a queue.  <a href="#ga8bdb0b39ec10ee344c8e65179800836b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga34d9cc6e8919398d18a1359ae72a821c">httpPutForService</a> (struct HttpQueue *q, HttpPacket *packet, <a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> serviceQ)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a packet onto the service queue.  <a href="#ga34d9cc6e8919398d18a1359ae72a821c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gac4ad79496f9054044a6c999384669d6a">httpPutPacket</a> (struct HttpQueue *q, HttpPacket *packet)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a packet onto a queue.  <a href="#gac4ad79496f9054044a6c999384669d6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga15c957cd47313affb413d681767a4763">httpPutPacketToNext</a> (struct HttpQueue *q, HttpPacket *packet)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a packet onto the next queue.  <a href="#ga15c957cd47313affb413d681767a4763"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gaf2897449db2b3cb92cd701a14a0a0a02">httpRemoveQueue</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a queue.  <a href="#gaf2897449db2b3cb92cd701a14a0a0a02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gafea79ab1e8d1bc8b9827594c4c1d2e56">httpResizePacket</a> (struct HttpQueue *q, HttpPacket *packet, <a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a packet.  <a href="#gafea79ab1e8d1bc8b9827594c4c1d2e56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga3ea3dc316a3c5b968eac6e5b6069ccf5">httpScheduleQueue</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a queue.  <a href="#ga3ea3dc316a3c5b968eac6e5b6069ccf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga78e8c0627028e112f31392ab3b49b64a">httpSendEndPacket</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an end packet.  <a href="#ga78e8c0627028e112f31392ab3b49b64a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gacbccba013b170c147cb39efea2344f0b">httpSendPackets</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send all queued packets.  <a href="#gacbccba013b170c147cb39efea2344f0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga5ed409b0c87172597fa7f928df1e7e77">httpServiceQueue</a> (HttpQueue *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Service a queue.  <a href="#ga5ed409b0c87172597fa7f928df1e7e77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga5bd57d28f2fbce408fc8232e4c8cc7b7">httpWillNextQueueAcceptPacket</a> (HttpQueue *q, HttpPacket *packet)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the downstream queue will accept this packet.  <a href="#ga5bd57d28f2fbce408fc8232e4c8cc7b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga1cc3389ca2a476dda61904b46d939740">httpWillNextQueueAcceptSize</a> (HttpQueue *q, <a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the downstream queue will accept a certain amount of data.  <a href="#ga1cc3389ca2a476dda61904b46d939740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#ga5599a178a2bab73929795952231d6e6a">httpWrite</a> (HttpQueue *q, <a class="elRef" href="mpr_8h.html#a0f128c3e0c83721af0220c00554e9c4e">cchar</a> *fmt,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a formatted string.  <a href="#ga5599a178a2bab73929795952231d6e6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gae1b8876619f533e26837e38cf5a6575d">httpWriteBlock</a> (HttpQueue *q, <a class="elRef" href="mpr_8h.html#a0f128c3e0c83721af0220c00554e9c4e">cchar</a> *buf, <a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a block of data to the queue.  <a href="#gae1b8876619f533e26837e38cf5a6575d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___http_queue.html#gad062a99a5fe2d4a79753b71d4be891d7">httpWriteString</a> (HttpQueue *q, <a class="elRef" href="mpr_8h.html#a0f128c3e0c83721af0220c00554e9c4e">cchar</a> *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a string of data to the queue.  <a href="#gad062a99a5fe2d4a79753b71d4be891d7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Queue object. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>The request pipeline consists of a full-duplex pipeline of stages. Each stage has two queues, one for outgoing data and one for incoming. A HttpQueue object manages the data flow for a request stage and has the ability to queue and process data, manage flow control and schedule packets for service. <br/>
<br/>
 Queue's provide open, close, put and service methods. These methods manage and respond to incoming packets. A queue can respond immediately to an incoming packet by processing or dispatching a packet in its put() method. Alternatively, the queue can defer processing by queueing the packet on it's service queue and then waiting for it's service() method to be invoked. <br/>
<br/>
 If a queue does not define a put() method, the default put method will be used which queues data onto the service queue. The default incoming put() method joins incoming packets into a single packet on the service queue. </dd></dl>
<dl class="user"><dt><b><b>API</b> Stability:</b></dt><dd>Evolving</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___http_conn.html" title="Http Connections.">HttpConn</a> <a class="el" href="group___http_packet.html" title="Packet object.">HttpPacket</a> <a class="el" href="group___http_queue.html" title="Queue object.">HttpQueue</a> <a class="el" href="group___http_queue.html#ga9148e04c9f1e0be26f5c05fa069671db" title="Disable a queue.">httpDisableQueue</a> <a class="el" href="group___http_queue.html#gab1edc4220fc6d43c9f3890a791203d2c" title="Discard all data from the queue.">httpDiscardData</a> <a class="el" href="group___http_queue.html#ga346146f107faba9923caa9e003c4d3a1" title="Enable a queue.">httpEnableQueue</a> httpFlushQueue <a class="el" href="group___http_queue.html#ga141d826d025030d4d8c6b3e29cc82b54" title="Get the room in the queue.">httpGetQueueRoom</a> <a class="el" href="group___http_queue.html#ga0312ce08a79bdfb49854b0693480b661" title="Test is the connection has received all incoming content.">httpIsEof</a> <a class="el" href="group___http_queue.html#gafb4d0f9b9d5caa21b605e015154de36e" title="Test if a packet is too big.">httpIsPacketTooBig</a> <a class="el" href="group___http_queue.html#gacd6cd97710d608b988e9169637dec43c" title="Determine if the queue is empty.">httpIsQueueEmpty</a> <a class="el" href="group___http_queue.html#ga7ca69588fa498e117f23b73956ae66f0" title="Join a packet onto the service queue.">httpJoinPacketForService</a> <a class="el" href="group___http_queue.html#ga476c8e99e1c02292781748edd59190dc" title="Join the packets together.">httpJoinPackets</a> httpOpenQueue <a class="el" href="group___http_queue.html#ga8bdb0b39ec10ee344c8e65179800836b" title="Put a packet back onto a queue.">httpPutBackPacket</a> <a class="el" href="group___http_queue.html#ga34d9cc6e8919398d18a1359ae72a821c" title="Put a packet onto the service queue.">httpPutForService</a> <a class="el" href="group___http_queue.html#gac4ad79496f9054044a6c999384669d6a" title="Put a packet onto a queue.">httpPutPacket</a> <a class="el" href="group___http_queue.html#ga15c957cd47313affb413d681767a4763" title="Put a packet onto the next queue.">httpPutPacketToNext</a> <a class="el" href="group___http_queue.html#gaf2897449db2b3cb92cd701a14a0a0a02" title="Remove a queue.">httpRemoveQueue</a> <a class="el" href="group___http_queue.html#gafea79ab1e8d1bc8b9827594c4c1d2e56" title="Resize a packet.">httpResizePacket</a> <a class="el" href="group___http_queue.html#ga3ea3dc316a3c5b968eac6e5b6069ccf5" title="Schedule a queue.">httpScheduleQueue</a> <a class="el" href="group___http_queue.html#ga78e8c0627028e112f31392ab3b49b64a" title="Send an end packet.">httpSendEndPacket</a> <a class="el" href="group___http_queue.html#gacbccba013b170c147cb39efea2344f0b" title="Send all queued packets.">httpSendPackets</a> <a class="el" href="group___http_queue.html#ga5ed409b0c87172597fa7f928df1e7e77" title="Service a queue.">httpServiceQueue</a> httpWillNextQueueAccept <a class="el" href="group___http_queue.html#ga1cc3389ca2a476dda61904b46d939740" title="Determine if the downstream queue will accept a certain amount of data.">httpWillNextQueueAcceptSize</a> <a class="el" href="group___http_queue.html#ga5599a178a2bab73929795952231d6e6a" title="Write a formatted string.">httpWrite</a> <a class="el" href="group___http_queue.html#gae1b8876619f533e26837e38cf5a6575d" title="Write a block of data to the queue.">httpWriteBlock</a> httpWriteBody <a class="el" href="group___http_queue.html#gad062a99a5fe2d4a79753b71d4be891d7" title="Write a string of data to the queue.">httpWriteString</a> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga9148e04c9f1e0be26f5c05fa069671db"></a><!-- doxytag: member="http.h::httpDisableQueue" ref="ga9148e04c9f1e0be26f5c05fa069671db" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpDisableQueue </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Mark a queue as disabled so that it will not be scheduled for service. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1edc4220fc6d43c9f3890a791203d2c"></a><!-- doxytag: member="http.h::httpDiscardData" ref="gab1edc4220fc6d43c9f3890a791203d2c" args="(HttpQueue *q, bool removePackets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpDiscardData </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>removePackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discard all data from the queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Discard data from the queue. If removePackets (not yet implemented) is true, then remove the packets otherwise, just discard the data and preserve the packets. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">removePackets</td><td>If true, the data packets will be removed from the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga346146f107faba9923caa9e003c4d3a1"></a><!-- doxytag: member="http.h::httpEnableQueue" ref="ga346146f107faba9923caa9e003c4d3a1" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpEnableQueue </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Enable a queue for service and schedule it to run. This will cause the service routine to run as soon as possible. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga289893521c40788edc06280530167a85"></a><!-- doxytag: member="http.h::httpGetPacket" ref="ga289893521c40788edc06280530167a85" args="(struct HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HttpPacket* httpGetPacket </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the next packet from a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Get the next packet. This will remove the packet from the queue and adjust the queue counts accordingly. If the queue was full and upstream queues were blocked, they will be enabled. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet removed from the queue. </dd></dl>

</div>
</div>
<a class="anchor" id="ga141d826d025030d4d8c6b3e29cc82b54"></a><!-- doxytag: member="http.h::httpGetQueueRoom" ref="ga141d826d025030d4d8c6b3e29cc82b54" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> httpGetQueueRoom </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the room in the queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Get the amount of data the queue can accept before being full. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A count of bytes that can be written to the queue </dd></dl>

</div>
</div>
<a class="anchor" id="ga0312ce08a79bdfb49854b0693480b661"></a><!-- doxytag: member="http.h::httpIsEof" ref="ga0312ce08a79bdfb49854b0693480b661" args="(struct HttpConn *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> httpIsEof </td>
          <td>(</td>
          <td class="paramtype">struct HttpConn *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test is the connection has received all incoming content. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>This tests if the connection is at an "End of File condition. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>HttpConn object created via $httpCreateConn </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if all receive content has been received </dd></dl>

</div>
</div>
<a class="anchor" id="gafb4d0f9b9d5caa21b605e015154de36e"></a><!-- doxytag: member="http.h::httpIsPacketTooBig" ref="gafb4d0f9b9d5caa21b605e015154de36e" args="(struct HttpQueue *q, HttpPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> httpIsPacketTooBig </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a packet is too big. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Test if a packet is too big to fit downstream. If the packet content exceeds the downstream queue's maximum or exceeds the downstream queue's requested packet size -- then this routine will return true. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the packet is too big for the downstream queue </dd></dl>

</div>
</div>
<a class="anchor" id="gacd6cd97710d608b988e9169637dec43c"></a><!-- doxytag: member="http.h::httpIsQueueEmpty" ref="gacd6cd97710d608b988e9169637dec43c" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> httpIsQueueEmpty </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if the queue is empty. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Determine if the queue has no packets queued. This does not test if the queue has no data content. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if there are no packets queued. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ca69588fa498e117f23b73956ae66f0"></a><!-- doxytag: member="http.h::httpJoinPacketForService" ref="ga7ca69588fa498e117f23b73956ae66f0" args="(struct HttpQueue *q, HttpPacket *packet, bool serviceQ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpJoinPacketForService </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>serviceQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join a packet onto the service queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Add a packet to the service queue. If the queue already has data, then this packet will be joined (aggregated) into the existing packet. If serviceQ is true, the queue will be scheduled for service. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to join to the queue </td></tr>
    <tr><td class="paramname">serviceQ</td><td>If true, schedule the queue for service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga476c8e99e1c02292781748edd59190dc"></a><!-- doxytag: member="http.h::httpJoinPackets" ref="ga476c8e99e1c02292781748edd59190dc" args="(HttpQueue *q, ssize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpJoinPackets </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join the packets together. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>This call joins data packets on the given queue up together up to the given maximum size. The maximum size is also limited by the downstream queue maximum packet size. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue to examine </td></tr>
    <tr><td class="paramname">size</td><td>The maximum sized packet that will be created by joining queue packets is the minimum of the given size and the downstream queues maximum packet size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8bdb0b39ec10ee344c8e65179800836b"></a><!-- doxytag: member="http.h::httpPutBackPacket" ref="ga8bdb0b39ec10ee344c8e65179800836b" args="(struct HttpQueue *q, HttpPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpPutBackPacket </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put a packet back onto a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Put the packet back onto the front of the queue. The queue's put() method is not called. This is typically used by the queue's service routine when a packet cannot complete processing. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to put back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34d9cc6e8919398d18a1359ae72a821c"></a><!-- doxytag: member="http.h::httpPutForService" ref="ga34d9cc6e8919398d18a1359ae72a821c" args="(struct HttpQueue *q, HttpPacket *packet, bool serviceQ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpPutForService </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a>&#160;</td>
          <td class="paramname"><em>serviceQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put a packet onto the service queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Add a packet to the service queue. If serviceQ is true, the queue will be scheduled for service. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to join to the queue </td></tr>
    <tr><td class="paramname">serviceQ</td><td>If true, schedule the queue for service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac4ad79496f9054044a6c999384669d6a"></a><!-- doxytag: member="http.h::httpPutPacket" ref="gac4ad79496f9054044a6c999384669d6a" args="(struct HttpQueue *q, HttpPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpPutPacket </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put a packet onto a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Put the packet onto the end of queue by calling the queue's put() method. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to put </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15c957cd47313affb413d681767a4763"></a><!-- doxytag: member="http.h::httpPutPacketToNext" ref="ga15c957cd47313affb413d681767a4763" args="(struct HttpQueue *q, HttpPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpPutPacketToNext </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put a packet onto the next queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Put a packet onto the next downstream queue by calling the downstreams queue's put() method. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference. The packet will not be queued on this queue, but rather on the queue downstream. </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to put </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2897449db2b3cb92cd701a14a0a0a02"></a><!-- doxytag: member="http.h::httpRemoveQueue" ref="gaf2897449db2b3cb92cd701a14a0a0a02" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpRemoveQueue </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Remove a queue from the request/response pipeline. This will remove a queue so that it does not participate in the pipeline, effectively removing the processing stage from the pipeline. This is useful to remove unwanted filters and to speed up pipeline processing </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafea79ab1e8d1bc8b9827594c4c1d2e56"></a><!-- doxytag: member="http.h::httpResizePacket" ref="gafea79ab1e8d1bc8b9827594c4c1d2e56" args="(struct HttpQueue *q, HttpPacket *packet, ssize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int httpResizePacket </td>
          <td>(</td>
          <td class="paramtype">struct HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize a packet. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Resize a packet if required so that it fits in the downstream queue. This may split the packet if it is too big to fit in the downstream queue. If it is split, the tail portion is put back on the queue. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to put </td></tr>
    <tr><td class="paramname">size</td><td>If size is &gt; 0, then also ensure the packet is not larger than this size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero if successful, otherwise a negative Mpr error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ea3dc316a3c5b968eac6e5b6069ccf5"></a><!-- doxytag: member="http.h::httpScheduleQueue" ref="ga3ea3dc316a3c5b968eac6e5b6069ccf5" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpScheduleQueue </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Schedule a queue by adding it to the schedule queue. Queues are serviced FIFO. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78e8c0627028e112f31392ab3b49b64a"></a><!-- doxytag: member="http.h::httpSendEndPacket" ref="ga78e8c0627028e112f31392ab3b49b64a" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpSendEndPacket </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send an end packet. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Create and send an end-of-stream packet downstream </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbccba013b170c147cb39efea2344f0b"></a><!-- doxytag: member="http.h::httpSendPackets" ref="gacbccba013b170c147cb39efea2344f0b" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpSendPackets </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send all queued packets. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Send all queued packets downstream </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5ed409b0c87172597fa7f928df1e7e77"></a><!-- doxytag: member="http.h::httpServiceQueue" ref="ga5ed409b0c87172597fa7f928df1e7e77" args="(HttpQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void httpServiceQueue </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Service a queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Service a queue by invoking its service() routine. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5bd57d28f2fbce408fc8232e4c8cc7b7"></a><!-- doxytag: member="http.h::httpWillNextQueueAcceptPacket" ref="ga5bd57d28f2fbce408fc8232e4c8cc7b7" args="(HttpQueue *q, HttpPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> httpWillNextQueueAcceptPacket </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpPacket *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if the downstream queue will accept this packet. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Test if the downstream queue will accept a packet. The packet will be resized if required in an attempt to get the downstream queue to accept it. If the downstream queue is full, disable this queue and mark the downstream queue as full and service it immediately to try to relieve the congestion. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to put </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the downstream queue will accept the packet. Use $httpSendPacketToNext to send the packet downstream </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cc3389ca2a476dda61904b46d939740"></a><!-- doxytag: member="http.h::httpWillNextQueueAcceptSize" ref="ga1cc3389ca2a476dda61904b46d939740" args="(HttpQueue *q, ssize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a1062901a7428fdd9c7f180f5e01ea056">bool</a> httpWillNextQueueAcceptSize </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if the downstream queue will accept a certain amount of data. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Test if the downstream queue will data of a given size. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to test for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the downstream queue will accept the given sized data. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5599a178a2bab73929795952231d6e6a"></a><!-- doxytag: member="http.h::httpWrite" ref="ga5599a178a2bab73929795952231d6e6a" args="(HttpQueue *q, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> httpWrite </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a0f128c3e0c83721af0220c00554e9c4e">cchar</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a formatted string. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Write a formatted string of data into packets onto the end of the queue. Data packets will be created as required to store the write data. This call may block waiting for the downstream queue to drain if it is or becomes full. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">fmt</td><td>Printf style formatted string </td></tr>
    <tr><td class="paramname">...</td><td>Arguments for fmt </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A count of the bytes actually written </dd></dl>

</div>
</div>
<a class="anchor" id="gae1b8876619f533e26837e38cf5a6575d"></a><!-- doxytag: member="http.h::httpWriteBlock" ref="gae1b8876619f533e26837e38cf5a6575d" args="(HttpQueue *q, cchar *buf, ssize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> httpWriteBlock </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a0f128c3e0c83721af0220c00554e9c4e">cchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a block of data to the queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Write a block of data into packets onto the end of the queue. Data packets will be created as required to store the write data. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer containing the write data </td></tr>
    <tr><td class="paramname">size</td><td>of the data in buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A count of the bytes actually written </dd></dl>

</div>
</div>
<a class="anchor" id="gad062a99a5fe2d4a79753b71d4be891d7"></a><!-- doxytag: member="http.h::httpWriteString" ref="gad062a99a5fe2d4a79753b71d4be891d7" args="(HttpQueue *q, cchar *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="mpr_8h.html#a7d08ccc1e981eb4d5a238641ac4ccfc1">ssize</a> httpWriteString </td>
          <td>(</td>
          <td class="paramtype">HttpQueue *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="mpr_8h.html#a0f128c3e0c83721af0220c00554e9c4e">cchar</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a string of data to the queue. </p>
<dl class="user"><dt><b><b>Description</b>:</b></dt><dd>Write a string of data into packets onto the end of the queue. Data packets will be created as required to store the write data. This call may block waiting for the downstream queue to drain if it is or becomes full. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Queue reference </td></tr>
    <tr><td class="paramname">s</td><td>String containing the data to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A count of the bytes actually written </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Sep 5 2011 12:19:39 for http by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
